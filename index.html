<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        .highlightCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            /* Makes sure the canvas doesn't interfere with mouse events */
        }
    </style>
</head>

<body style="position: relative;">
    <div data-avoid="true"
        style="position: fixed; right: 10px; background-color: greenyellow; padding: 10px; display: flex; gap: 10px; flex-direction: column;">
        <div>Options:</div>
        <button onclick="start()">Start detecting</button>
        <button onclick="stop()">Stop detecting</button>
        <!-- <input type="color" onchange="color_change()" id="default_color" value="#ffff00" /> -->
        <input type="range" onchange="saturation_change()" value="10" min="0" max="10" step="1" />
        Add new word:
        <input type="text" id="add_word_text_input" autocomplete="off" list="new_words_datalist" />
        <datalist id="new_words_datalist">
        </datalist>
        Remove word:
        <input type="text" id="remove_word_text_input" autocomplete="off" list="active_words_datalist" />
        <datalist id="active_words_datalist">
        </datalist>
        Active words:
        <div id="list_of_words"></div>
    </div>
    <div style="margin-left: 10px; margin-right: 250px;" id="main_content">

        <h3>
            "A DREAM"
        </h3>
        <h4>
            Taras Shevchenko
        </h4>

        <hr />
        Each man on earth has his own fate, <br />
        Each one his highway wide: <br />
        This one builds up, that one lays waste, <br />
        And that casts greedy eyes <br />
        O’er all the globe, to find somewhere <br />
        A land not yet enslaved, <br />
        Which he could conquer and then bear <br />
        With him into the grave. <br />

        <hr />
        This fellow in his neighbour's home <br />
        His host cleans out at cards, <br />
        While that one in a corner hones <br />
        A blade for brother's heart. <br />
        Then there's the solid citizen, <br />
        The worthy, pious kind, <br />
        Who'll creep up like a cat and then <br />
        Bide patiently his time <br />
        Until hard luck hits your affairs, <br />
        Then pounce! — Don't plead your cause: <br />
        Your wife's appeals and children's tears <br />
        Won't save you from his claws. <br />
        And that one, generous and grand, <br />
        The fervent patriot, <br />
        So deeply loves his native land, <br />
        So worries o'er its lot, <br />
        As from his country's heart he sucks <br />
        The blood as though it was water!... <br />
        The brethren meanwhile sit and look, <br />
        Their eyes agape like saucers! <br />
        And bleat like lambs: "Perhaps it was <br />
        Thus ordained from on high." <br />
        That's how it's meant to be! Because <br />
        There's no God in the sky! <br />
        You pull your yoke until your breath <br />
        Gives out and you are done, <br />
        Yet pray for heaven after death? <br />
        In vain! There's none! There's none! <br />
        Your labour's lost. Come to! Come to! <br />
        In this world every one — <br />
        The princes, and the beggars, too, <br />
        They all are Adam's sons. <br />
        Both he... and he... What's this I prate? <br />
        What is it all about? <br />
        I banquet every single day, <br />
        Carouse day in, day out, <br />
        While you with envy burn and hate! <br />
        Don't scold: 'Twill do no good - <br />
        I'm deaf to you! I drink my own, <br />
        Not other people's blood! <br />

        <hr />

        Such thoughts went flitting through my head <br />
        As tipsy from a merry feast <br />
        In dead of night, on reeling feet, <br />
        I made my way to home and bed. <br />
        No bawling child or nagging spouse <br />
        Have I to spoil my rest — <br />
        With perfect peace I'm blest <br />
        Both in my mind and in my house. <br />
        I climbed into my bed <br />
        And soon slept like the dead. <br />
        And when a man has had a few, <br />
        Though cannon roar he still will snore, <br />
        He'll sleep whate'er you do. <br />
        <hr />

        Oh, what a vision rare I saw <br />
        In sleep that night: <br />
        A staunch abstainer would get iight, <br />
        A tightwad would a coin bestow, <br />
        If they could only get a glance. <br />
        But not a chance! <br />
        I dreamed: high in the air's expanse <br />
        It was as though an owl was flying <br />
        Over meadows, over valleys, <br />
        Over river banks and gulleys, <br />
        Over steppes and over forests. <br />
        And in the owl's wake I flew, too, <br />
        And flying, bid the earth adieu: <br />
        <hr />

        "Goodbye, O world, O earth, farewell, <br />
        Unfriendly land, goodbye! <br />
        My searing pain, my tortures cruel <br />
        Above the clouds I'll hide. <br />
        And as for you, my dear Ukraine, <br />
        I'll leave the clouds behind <br />
        And fall with dew to talk with you, <br />
        Poor widow-country mine. <br />
        I'll come at midnight when the dew <br />
        Falls heavy on the fields; <br />
        And softly-sadly we will talk <br />
        Of what the future yields. <br />
        Until the rising of the sun <br />
        We'll talk about your woes, <br />
        Until your infant sons are grown <br />
        And rise against the foes. <br />
        Goodbye, my lovely, poor Ukraine, <br />
        0 widow-land of mine! <br />
        Your children teach the living truth - <br />
        That justice is divine!" <br />
        <hr />

    </div>

    <hr />
    <hr />
    <hr />
    <hr />

    <div style="margin-left: 10px; margin-right: 250px;" id="main_content1">

        <h3>
            "A DREAM"
        </h3>
        <h4>
            Taras Shevchenko
        </h4>

        <hr />
        Each man on earth has his own fate, <br />
        Each one his highway wide: <br />
        This one builds up, that one lays waste, <br />
        And that casts greedy eyes <br />
        O’er all the globe, to find somewhere <br />
        A land not yet enslaved, <br />
        Which he could conquer and then bear <br />
        With him into the grave. <br />

        <hr />
        This fellow in his neighbour's home <br />
        His host cleans out at cards, <br />
        While that one in a corner hones <br />
        A blade for brother's heart. <br />
        Then there's the solid citizen, <br />
        The worthy, pious kind, <br />
        Who'll creep up like a cat and then <br />
        Bide patiently his time <br />
        Until hard luck hits your affairs, <br />
        Then pounce! — Don't plead your cause: <br />
        Your wife's appeals and children's tears <br />
        Won't save you from his claws. <br />
        And that one, generous and grand, <br />
        The fervent patriot, <br />
        So deeply loves his native land, <br />
        So worries o'er its lot, <br />
        As from his country's heart he sucks <br />
        The blood as though it was water!... <br />
        The brethren meanwhile sit and look, <br />
        Their eyes agape like saucers! <br />
        And bleat like lambs: "Perhaps it was <br />
        Thus ordained from on high." <br />
        That's how it's meant to be! Because <br />
        There's no God in the sky! <br />
        You pull your yoke until your breath <br />
        Gives out and you are done, <br />
        Yet pray for heaven after death? <br />
        In vain! There's none! There's none! <br />
        Your labour's lost. Come to! Come to! <br />
        In this world every one — <br />
        The princes, and the beggars, too, <br />
        They all are Adam's sons. <br />
        Both he... and he... What's this I prate? <br />
        What is it all about? <br />
        I banquet every single day, <br />
        Carouse day in, day out, <br />
        While you with envy burn and hate! <br />
        Don't scold: 'Twill do no good - <br />
        I'm deaf to you! I drink my own, <br />
        Not other people's blood! <br />

        <hr />

        Such thoughts went flitting through my head <br />
        As tipsy from a merry feast <br />
        In dead of night, on reeling feet, <br />
        I made my way to home and bed. <br />
        No bawling child or nagging spouse <br />
        Have I to spoil my rest — <br />
        With perfect peace I'm blest <br />
        Both in my mind and in my house. <br />
        I climbed into my bed <br />
        And soon slept like the dead. <br />
        And when a man has had a few, <br />
        Though cannon roar he still will snore, <br />
        He'll sleep whate'er you do. <br />
        <hr />

        Oh, what a vision rare I saw <br />
        In sleep that night: <br />
        A staunch abstainer would get iight, <br />
        A tightwad would a coin bestow, <br />
        If they could only get a glance. <br />
        But not a chance! <br />
        I dreamed: high in the air's expanse <br />
        It was as though an owl was flying <br />
        Over meadows, over valleys, <br />
        Over river banks and gulleys, <br />
        Over steppes and over forests. <br />
        And in the owl's wake I flew, too, <br />
        And flying, bid the earth adieu: <br />
        <hr />

        "Goodbye, O world, O earth, farewell, <br />
        Unfriendly land, goodbye! <br />
        My searing pain, my tortures cruel <br />
        Above the clouds I'll hide. <br />
        And as for you, my dear Ukraine, <br />
        I'll leave the clouds behind <br />
        And fall with dew to talk with you, <br />
        Poor widow-country mine. <br />
        I'll come at midnight when the dew <br />
        Falls heavy on the fields; <br />
        And softly-sadly we will talk <br />
        Of what the future yields. <br />
        Until the rising of the sun <br />
        We'll talk about your woes, <br />
        Until your infant sons are grown <br />
        And rise against the foes. <br />
        Goodbye, my lovely, poor Ukraine, <br />
        0 widow-land of mine! <br />
        Your children teach the living truth - <br />
        That justice is divine!" <br />
        <hr />

    </div>
    <div>
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <hr />
    </div>

</body>

<script>
    const is_paint_worklet_available = "paintWorklet" in CSS;
    const not_available_message = '`paintWorklet` is not available in your browser';
    let words_to_search = ['what', 'man', 'thoughts', 'luck', 'come', 'is', 'heart', 'then', 'not', 'river', 'lot'];
    const words_to_avoid = [''];
    const default_color = '#ffff00';
    let unique_words = [];

    async function wait(time) {
        return new Promise((resolve) => {
            setTimeout(resolve, time);
        });
    }

    /**
     * Represents a match object.
     * @typedef {Object} MatchObject
     * @property {Range} range - The range of the match.
     * @property {number} index - The index of the match.
     * @property {Node} node - The node of the match.
     * @property {HTMLElement} first_block_parent - The first block parent of the match.
     * @property {string} string - The string content of the match.
     * @property {number} start - The start index of the match.
     * @property {number} end - The end index of the match.
     */

    /**
     * @typedef {Object.<string, [number, number, number, number][]>} ColorDataMap
     * An object where each key is a color code and the value is an array of arrays of rectangles.
     */

    /**
     * @typedef {Object.<string, { coordinates_map: [number, number, number, number][], word: string }>} ColorDataMapWithWord
     * An object where each key is a color code and the value is an array of arrays of rectangles.
     */

    class Highlighter {
        detecting = false;
        /** @type {Set<Text>} */
        text_nodes = new Set();
        /** @type {MatchObject[]} */
        matches = [];
        /** @type {Map<HTMLElement, MatchObject[]>} */
        matches_by_blocks = new Map();
        /** @type {string[]} */
        strings = [];
        saturation = 10;
        number_of_matches_all = 0;
        number_of_matches_visible = 0;
        /** @type {HTMLStyleElement} */
        style_main = document.createElement("style");
        /** @type {Map<HTMLElement, string>} */
        blocks_to_last_repaint_id = new Map();
        /** @type {Map<string, string>} */
        word_color_map = new Map();

        /** @type {Map<HTMLElement, { color_data: ColorDataMapWithWord, parent_top: number, parent_left: number, block: HTMLElement }>} */
        all_blocks_color_map = new Map();

        async init(all_words, exclude_words) {
            // init_styles
            this.set_highlight_color(default_color);
            document.head.append(this.style_main);

            this.detecting = true;
            this.strings = all_words.reduce((acc, word) => (!exclude_words.includes(word)) ? [...acc, word] : acc, []);

            this.update_text_nodes();
            this.get_colors_for_words();
            this.update_matches();

            // this.set_colors_for_words(words_to_search);

            // init_event_listeners
            // window.addEventListener("mousedown", (e) => this.handle_user_interaction(), true);
            // window.addEventListener("keydown", (e) => this.handle_user_interaction(), true);
            // window.addEventListener("wheel", (e) => this.handle_user_interaction(), true);
            // window.addEventListener("scroll", (e) => this.handle_user_interaction(), true);
            // window.addEventListener("resize", (e) => this.handle_user_interaction(), true);
        }

        // async handle_user_interaction() {
        //     if (this.detecting) {
        //         this.update_text_nodes();
        //         this.update_matches();
        //     }
        // }

        /** @param {string} color */
        set_highlight_color(color) {
            this.style_main.innerHTML = `html { --highlight-color: ${color}; }`;
        }

        // /** @param {string[]} words_to_search */
        // set_colors_for_words(words_to_search) {
        //     console.log('words_to_search', words_to_search);
        //     const highlight_color = this.get_highlight_color();
        //     const words_color = words_to_search.map((word) => ([word, highlight_color]));
        //     this.style_main.style.setProperty("--words-color", JSON.stringify(words_color));
        // }

        // /** @param {string[]} words_to_search @param {HTMLElement} block */
        // set_1_colors_for_words(words_to_search, block) {
        //     const highlight_color = this.get_highlight_color();
        //     const words_color = words_to_search.map((word) => ([word, 'red']));
        //     block.style.setProperty("--words-color", JSON.stringify(words_color));
        // }

        get_highlight_color() {
            return getComputedStyle(document.documentElement).getPropertyValue('--highlight-color');
        }

        // /** @param {HTMLElement} block */
        // get_words_from_block(block) {
        //     const matches = this.matches_by_blocks.get(block);
        //     const words = [];
        //     if (matches) {
        //         for (const match of matches) {
        //             if (!words.includes(match.string)) {
        //                 words.push(match.string)
        //             }
        //         }
        //     }
        //     return words;
        // }

        /**
         * @param {MouseEvent['clientX']} client_x - The x-coordinate of the client point.
         * @param {MouseEvent['clientY']} client_y - The y-coordinate of the client point.
         * @returns { ['word', DOMRect, string] | ['nothing'] } An array containing information about the data at the specified point.
         */
        get_data_from_point(client_x, client_y) {
            const elements = document.elementsFromPoint(client_x, client_y);
            if (!elements.length) return ['nothing'];

            for (const element of elements) {
                const matches = this.matches_by_blocks.get(element);
                if (matches) {
                    for (const match of matches) {
                        const rects = match.range.getClientRects();
                        for (const rect of rects) {
                            if (
                                rect.x < client_x &&
                                rect.y < client_y &&
                                rect.x + rect.width > client_x &&
                                rect.y + rect.height > client_y
                            ) {
                                return ["word", rect, match.string];
                            }
                        }
                    }
                } else if (element.dataset.avoid) {
                    return ["avoid"];
                }
            }
            return ['nothing']
        }

        /**
         * @param {string[]} all_words 
         * @param {string[]} exclude_words 
         * @param {number} saturation 
         */
        restart_detecting(all_words, exclude_words, saturation = this.saturation) {
            this.detecting = true;
            this.reset();

            this.saturation = saturation;
            this.strings = all_words.reduce((acc, word) => (!exclude_words.includes(word)) ? [...acc, word] : acc, []);
            this.update_text_nodes();
            // this.get_colors_for_words();
            this.update_matches();
        }

        stop_detecting() {
            this.detecting = false;
            this.reset();
        }

        reset() {
            this.un_paint_blocks();
            this.text_nodes = new Set();
            this.matches_by_blocks = new Map();
            this.number_of_matches_all = 0;
            this.number_of_matches_visible = 0;
        }

        update_text_nodes() {
            /** @type {Text|undefined} */
            let text_node;
            const walk = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function (node) {
                        // Check if the parent element of the text node has id 'avoid-element', if yes, skip it
                        // console.log('node.parentElement',
                        //     // node.parentElement,
                        //     { avoid: node.parentElement.dataset.avoid }
                        // );
                        // let ancestor = node.parentNode;
                        // while (ancestor !== null) {
                        //     if (ancestor.dataset.avoid) {
                        //         return NodeFilter.FILTER_SKIP; // Skip this text node
                        //     }
                        //     ancestor = ancestor.parentNode;
                        // }
                        return NodeFilter.FILTER_ACCEPT; // Accept this text node
                        // if (node.parentElement && node.parentElement.dataset.avoid) {
                        //     return NodeFilter.FILTER_SKIP; // Skip this text node
                        // } else {
                        //     return NodeFilter.FILTER_ACCEPT; // Accept this text node
                        // }
                    }
                }
            );
            function isDescendantOfAvoidElement(node) {
                while (node !== null) {
                    if (node.nodeType === Node.ELEMENT_NODE && node.dataset.avoid) {
                        return true;
                    }
                    node = node.parentNode;
                }
                return false;
            }

            while ((text_node = walk.nextNode())) {
                if (isDescendantOfAvoidElement(text_node)) {
                    // If the node is within an element with dataset.avoid, skip it
                    continue;
                }
                // console.log('text_node', text_node);
                if (!this.text_nodes.has(text_node)) {
                    this.text_nodes.add(text_node);
                }
            }
        }

        /**
         * @param {string} str
         * @param {string[]} asl_words
         */
        get_words_with_indexes(str, asl_words) {
            const matches = str.match(/[a-zA-Z0-9\$\&\_\+\-\:\^\.\']+|[^a-zA-Z0-9\$\&\_\+\-\:\^\.\']+/g);
            if (!matches) return [];

            const words = [];
            let index = 0;
            for (let i = 0; i < matches.length; i++) {
                if (matches[i]) {
                    const option = matches[i].toLowerCase()
                    if (asl_words.includes(option)) {
                        words.push({ index, text: option });
                    }
                    index += option.length;
                }
            }
            return words;
        }

        /** @param {Text} node */
        get_first_block_parent(node) {
            while (true) {
                const parentElement = node.parentElement;
                node = node.parentElement; // TODO: do not mutate node, try to save it in a new variable

                if (!parentElement) return null;

                const display = window.getComputedStyle(parentElement).display;
                if (display === "block") return parentElement;
            }
        }

        get_colors_for_words() {
            const highlight_color = this.get_highlight_color();
            for (let node of this.text_nodes) {
                let text = node.nodeValue;
                if (!text) return;

                const words_with_indexes = this.get_words_with_indexes(text, this.strings);
                if (words_with_indexes.length < 0) return;

                for (const word of words_with_indexes) {
                    if (!this.word_color_map.has(word.text)) {
                        this.word_color_map.set(word.text, highlight_color);
                    }
                }
            }
        }

        update_matches() {
            loop_1: for (let node of this.text_nodes) {
                this.text_nodes.delete(node);

                let text = node.nodeValue;
                if (!text) return;

                const words_with_indexes = this.get_words_with_indexes(text, this.strings);
                if (words_with_indexes.length < 0) return;

                const first_block_parent = this.get_first_block_parent(node);
                if (!first_block_parent) return;

                /** @type {MatchObject[]} */
                const matches = [];
                if (!this.matches_by_blocks.has(first_block_parent)) {
                    this.matches_by_blocks.set(first_block_parent, []);
                    const resize_observer = new ResizeObserver(() => {
                        this.paint_block(first_block_parent);
                    });
                    resize_observer.observe(first_block_parent);
                }
                loop_2: for (const word of words_with_indexes) {
                    this.number_of_matches_all += 1;
                    if ((this.number_of_matches_visible / this.number_of_matches_all) <= this.saturation / 10) {
                        this.number_of_matches_visible += 1;
                    } else {
                        continue loop_2;
                    }

                    const range = document.createRange();
                    range.setStart(node, word.index);
                    range.setEnd(node, word.index + word.text.length);
                    matches.push({
                        range,
                        index: word.index,
                        node,
                        first_block_parent,
                        string: word.text,
                        start: word.index,
                        end: word.index + word.text.length,
                    });
                    // if (!this.word_color_map.has(word.text)) {
                    //     this.word_color_map.set(word.text, highlight_color)
                    // }
                }
                if (first_block_parent) {
                    const set = this.matches_by_blocks.get(first_block_parent);
                    for (let match of matches) {
                        set.push(match);
                    }
                    this.paint_block(first_block_parent);
                }
            }
        }

        un_paint_blocks() {
            for (const block of this.matches_by_blocks.keys()) {
                const block_style = window.getComputedStyle(block);
                if (block_style.background === "rgba(0, 0, 0, 0) paint(signspaces-paint) repeat scroll 0% 0% / auto padding-box border-box") {
                    block.style.setProperty("--words-color", "");
                    block.style.setProperty("background", "");
                }
            }
        }


        /** 
         * @param {HTMLElement} block
         * @param {MatchObject[]} matches
         */
        get_block_color_map(block, matches) {
            const block_map = {};
            /**
             * @type {ColorDataMap}
             */
            const block_color_map = {};

            /**
             * @type {ColorDataMapWithWord}
             */
            const block_color_map_with_word = {};

            const block_rect = block.getBoundingClientRect();
            for (const match of matches) {
                try {
                    const match_rect_list = match.range.getClientRects();
                    for (const match_rect of match_rect_list) {
                        const item_x = match_rect.left - block_rect.left;
                        const item_y = match_rect.top - block_rect.top;
                        const item_width = match_rect.width;
                        const item_height = match_rect.height;
                        const block_item = [
                            item_x,
                            item_y,
                            item_width,
                            item_height,
                        ];
                        if (block_map[match.string]) {
                            block_map[match.string].push(block_item)
                        } else {
                            block_map[match.string] = [block_item];
                        }
                    }
                } catch (e) {
                    console.log("error", e);
                }
            }
            Object.entries(block_map).map(([word, coordinates], index) => {
                const color = this.word_color_map.get(word); // word.length > 3 ? 'red' : 'yellowgreen';
                if (block_color_map[color]) {
                    block_color_map[color].push(coordinates)
                } else {
                    block_color_map[color] = [coordinates];
                }

                if (block_color_map_with_word[color]) {
                    block_color_map_with_word[color].push({
                        coordinates_map: coordinates,
                        word
                    })
                } else {
                    block_color_map_with_word[color] = [{
                        coordinates_map: coordinates,
                        word
                    }];
                }
            })

            /** 
             * @param {HTMLElement} block
             */
            function getPageY(block) {
                const rect = block.getBoundingClientRect();
                const pageY = rect.top + window.pageYOffset;
                return pageY;
            }

            /** 
             * @param {HTMLElement} block
             */
            function getPageX(block) {
                const rect = block.getBoundingClientRect();
                const pageX = rect.left + window.pageXOffset;
                // console.log('window.pageXOffset', window.pageXOffset, rect.left);
                return pageX;
            }

            if (Object.keys(block_color_map).length) {
                const block_to = getPageY(block);
                const block_toX = getPageX(block);
                // const rect = block.getBoundingClientRect();
                // console.log(block, rect.top, getPageY(block));
                this.all_blocks_color_map.set(block, {
                    color_data: block_color_map_with_word,
                    parent_top: block_to,
                    parent_left: block_toX,
                    block
                });
            }
            // console.log('block_color_map', block_color_map_with_word);
            // console.log('this.all_blocks_color_map', this.all_blocks_color_map, this.word_color_map);
            return block_color_map;
        }

        get_id() {
            return Date.now().toString(36) + Math.floor(Math.random() * 1_000_000_000_000).toString(36);
        }

        /** @param {HTMLElement} block */
        async paint_block(block) {
            const this_id = this.get_id();
            this.blocks_to_last_repaint_id.set(block, this_id);
            // await wait(500); // we can add delay before show highlights

            const matches = this.matches_by_blocks.get(block);
            if (!matches) return;

            const last_id = this.blocks_to_last_repaint_id.get(block);
            if (this_id !== last_id) return;

            const block_style = window.getComputedStyle(block);
            if (
                block_style.background === "rgba(0, 0, 0, 0) none repeat scroll 0% 0% / auto padding-box border-box" ||
                block_style.background === "rgba(0, 0, 0, 0) paint(signspaces-paint) repeat scroll 0% 0% / auto padding-box border-box"
            ) {
            } else {
                return;
            }

            const block_color_map = this.get_block_color_map(block, matches);
            if (Object.keys(block_color_map).length) {
                block.style.setProperty("--words-color", JSON.stringify(block_color_map));
                block.style.background = `paint(signspaces-paint)`;
            }
        }

        /**
         *  @param {string} word
         *  @param {string} color
         */
        set_color_for_word(word, color) {
            if (this.word_color_map.has(word)) {
                this.word_color_map.set(word, color);
                this.update_text_nodes();
                this.update_matches()
            } else {
                this.word_color_map.set(word, color);
            }
        }

        /**
         *  @param {string} word
         */
        get_all_coordinates_for_word(word) {
            const color_for_word = this.word_color_map.get(word);
            // console.log('color_for_word', word, ": ", color_for_word);
            const all_coordinates = [];
            this.all_blocks_color_map.forEach((item) => {
                const { color_data, parent_top, parent_left, block } = item;
                // console.log('item', color_data);
                Object.entries(color_data).forEach(([color, coordinates]) => {
                    if (color === color_for_word) {
                        const this_word_coordinates = coordinates.filter(({ word: word_ }) => {
                            return word === word_;
                        });
                        // console.log('color', color, coordinates, parent_top, this_word_coordinates);
                        all_coordinates.push({
                            coordinates: this_word_coordinates.flat(1),
                            top: parent_top,
                            left: parent_left,
                            block,
                        });
                    };
                });
            });
            // console.log('all_coordinates', all_coordinates);
            return all_coordinates;
        }


        /**
         *  @param {ColorDataMapWithWord[x]['coordinates_map']} coordinates
         *  @param {number} left
         *  @param {number} top
         */
        update_word_color_by_coordinates(coordinates, left, top) {
            // console.log('coordinates', coordinates, left);
            let [item_x, item_y, item_width, item_height] = coordinates;

            let canvas = document.querySelector(".highlightCanvas");
            if (!canvas) {
                canvas = document.createElement("canvas");
                canvas.className = 'highlightCanvas';
                canvas.width = document.documentElement.scrollWidth;
                canvas.height = document.documentElement.scrollHeight;
            }
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            this.roundRect(ctx, item_x + left, item_y + top - item_height, item_width, item_height);
            document.body.appendChild(canvas)
        }

        /**
         * Draws a rounded rectangle on the canvas context.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         * @param {number} x - The x-coordinate of the rectangle's starting point.
         * @param {number} y - The y-coordinate of the rectangle's starting point.
         * @param {number} width - The width of the rectangle.
         * @param {number} height - The height of the rectangle.
         * @param {number} radius - The corner radius of the rectangle.
         * @param {number} horizontal_padding - Horizontal padding.
         * @param {number} vertical_padding - Vertical padding.
         */
        roundRect(ctx, x, y, width, height, radius = 10, horizontal_padding = 4, vertical_padding = 1) {
            if (width < 2 * radius) {
                radius = width / 2;
            }
            if (height < 2 * radius) {
                radius = height / 2;
            }

            x -= horizontal_padding;
            y -= vertical_padding;
            width += 2 * horizontal_padding;
            height += 2 * vertical_padding;

            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.arcTo(x + width, y, x + width, y + height, radius);
            ctx.arcTo(x + width, y + height, x, y + height, radius);
            ctx.arcTo(x, y + height, x, y, radius);
            ctx.arcTo(x, y, x + width, y, radius);
            ctx.closePath();
            ctx.fill();
        }
    };

    const highlighter = new Highlighter();

    document.querySelector('#add_word_text_input').addEventListener("keypress", function (event) {
        if (event.key === "Enter") {
            add_new_word();
        }
    });

    document.querySelector('#remove_word_text_input').addEventListener("keypress", function (event) {
        if (event.key === "Enter") {
            remove_new_word();
        }
    });

    const get_all_words_from_main_content = () => {
        const main_content = document.querySelector('#main_content');
        if (main_content) {
            const innerText = document.querySelector('#main_content').innerText;
            unique_words = [...new Set(innerText.split('\n').map((word) => word.split(' ')).flat().map((word) => word.replace(/[^a-zA-Z]/g, '').toLowerCase()))];
        }
    }

    const update_active_words_datalist = () => {
        const active_words_datalist = document.querySelector('#active_words_datalist');
        active_words_datalist.innerHTML = '';
        for (const word of words_to_search) {
            active_words_datalist.innerHTML += `
                <option value="${word}"></option>
            `;
        }
    }

    const update_new_words_datalist = () => {
        const new_words_datalist = document.querySelector('#new_words_datalist');
        new_words_datalist.innerHTML = '';
        for (const word of unique_words) {
            new_words_datalist.innerHTML += `
                <option value="${word}"></option>
            `;
        }
    }

    const update_list_of_words = () => {
        const list_of_words = document.querySelector('#list_of_words');
        list_of_words.innerHTML = '';
        for (const word of words_to_search) {
            list_of_words.innerHTML += `
                <li style="display: flex; justify-content: space-between">${word}
                    <input type="color" onchange="color_change_word('${word}')" value="#ffff00" name="${word}" />
                    <button data-word="${word}" data-show="0">\\|</button>
                </li>
            `;
        }

        /**
         *  @param {string} word
         */
        const get_filtered_flat_items = (word) => {
            const all_coordinates = highlighter.get_all_coordinates_for_word(word);
            // console.log('all_coordinates', all_coordinates);
            const prepared_to_navigate = all_coordinates.map(({ coordinates, top, left, block }) => {
                // console.log('coordinates, top', coordinates, top);
                const new_items = coordinates.map(({ coordinates_map }) => {
                    // console.log('coordinates_map', coordinates_map);
                    return coordinates_map.map((coordinate_map) => {
                        const [x, y] = coordinate_map;
                        return ({
                            y, top, coordinate_map, block, left
                        })
                    })
                });

                // console.log('new_items', new_items);
                return new_items;
            });

            const flat_items = prepared_to_navigate.flat(2);

            const filtered_flat_items = [];
            const seen = new Set();

            flat_items.forEach(item => {
                const identifier = `${item.y}-${item.top}`;
                if (!seen.has(identifier)) {
                    filtered_flat_items.push(item);
                    seen.add(identifier);
                }
            });

            return filtered_flat_items;
        }

        document.querySelectorAll("button[data-word]").forEach((button) => {
            const word = button.dataset?.word;

            if (word) {
                const filtered_flat_items = get_filtered_flat_items(word);
                button.textContent = `(${0}/${filtered_flat_items.length})`;
            }

            button.addEventListener("click", function (event) {
                const word = event.target.dataset.word;
                const show_old = event.target.dataset.show;
                let show_new = +show_old + 1;
                button.setAttribute('data-show', show_new);
                const filtered_flat_items = get_filtered_flat_items(word);

                let current_show = show_new;
                let show_current_word_coordinates = filtered_flat_items[0];
                if (filtered_flat_items.length > show_new) {
                    show_current_word_coordinates = filtered_flat_items[show_new - 1];
                } else {
                    button.setAttribute('data-show', "0");
                    show_current_word_coordinates = filtered_flat_items[filtered_flat_items.length - 1];
                }
                // console.log('show_current_word_coordinates', show_current_word_coordinates);
                button.textContent = `(${current_show}/${filtered_flat_items.length})`;

                // console.log('prepared_to_navigate', filtered_flat_items, show_current_word_coordinates);
                window.scrollTo({
                    top: show_current_word_coordinates.y + show_current_word_coordinates.top,
                    behavior: 'smooth'
                });
                highlighter.update_word_color_by_coordinates(
                    show_current_word_coordinates.coordinate_map,
                    show_current_word_coordinates.left,
                    show_current_word_coordinates.top,
                );
            });
        })
        update_active_words_datalist();
        update_new_words_datalist();
    }
    const add_new_word = () => {
        if (!is_paint_worklet_available) {
            console.log(not_available_message);
            return
        }
        const new_word = document.querySelector('#add_word_text_input');
        if (!new_word) return;

        if (words_to_search.find((word) => word === new_word.value)) {
            new_word.value = '';
            return
        };

        words_to_search.push(new_word.value.toLowerCase());
        highlighter.restart_detecting(words_to_search, words_to_avoid);
        update_list_of_words();
        highlighter.set_color_for_word(new_word.value.toLowerCase(), highlighter.get_highlight_color());
        new_word.value = '';
    }
    const remove_new_word = () => {
        if (!is_paint_worklet_available) {
            console.log(not_available_message);
            return
        }
        const word_to_remove = document.querySelector('#remove_word_text_input');
        if (!word_to_remove) return;

        if (words_to_search.find((word) => word === word_to_remove.value)) {
            words_to_search = words_to_search.filter((word) => word !== word_to_remove.value);
            highlighter.restart_detecting(words_to_search, words_to_avoid);
            update_list_of_words();
        };
        word_to_remove.value = '';
    }
    const start = () => {
        if (!is_paint_worklet_available) {
            console.log(not_available_message);
            return
        }
        highlighter.restart_detecting(words_to_search, words_to_avoid);
    }
    const stop = () => {
        if (!is_paint_worklet_available) {
            console.log(not_available_message);
            return
        }
        highlighter.stop_detecting();
    }
    // const color_change = () => {
    //     if (!is_paint_worklet_available) {
    //         console.log(not_available_message);
    //         return
    //     }
    //     const color_input = document.querySelector('#default_color');
    //     if (!color_input) return;

    //     highlighter.set_highlight_color(color_input.value);
    // }
    const color_change_word = (value) => {
        if (!is_paint_worklet_available) {
            console.log(not_available_message);
            return
        }
        const color_input = document.querySelector(`input[name="${value}"]`);
        if (!color_input) return;

        highlighter.set_color_for_word(value, color_input.value);
    }
    const saturation_change = (value) => {
        if (!is_paint_worklet_available) {
            console.log(not_available_message);
            return
        }
        const saturation_input = document.querySelector('input[type="range"]');
        if (!saturation_input) return;

        highlighter.restart_detecting(words_to_search, words_to_avoid, saturation_input.value);
    }
    (async () => {
        if (is_paint_worklet_available) {
            try {
                await highlighter.init(words_to_search, words_to_avoid);
                get_all_words_from_main_content();
                update_list_of_words();

                await CSS.paintWorklet.addModule("checkboardWorklet.js")
                console.log('paintWorklet:OK');
                document.addEventListener(
                    "mousemove",
                    async ({ clientX, clientY }) => {
                        const [data_type, rect, string] = highlighter.get_data_from_point(clientX, clientY);
                        // console.log('data_type', data_type);
                        switch (data_type) {
                            case 'word': {
                                // console.log('word:', string);
                                break;
                            }
                            case 'nothing': {
                                // console.log('nothing');
                                break;
                            }
                            case 'avoid': {
                                // console.log('avoid container');
                                break;
                            }
                            default:
                                break;
                        }
                    },
                    true
                );
            } catch (error) {
                console.log('paintWorklet:ERROR');
            }
        } else {
            console.log(not_available_message);
        }
    })();
</script>

</html>