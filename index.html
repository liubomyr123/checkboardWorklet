<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body style="position: relative;">
    <div
        style="position: fixed; right: 10px; background-color: greenyellow; padding: 10px; display: flex; gap: 10px; flex-direction: column;">
        <div>Options:</div>
        <button onclick="start()">Start detecting</button>
        <button onclick="stop()">Stop detecting</button>
        <input type="color" onchange="color_change()" value="#ffff00" />
        <input type="range" onchange="saturation_change()" value="10" min="0" max="10" step="1" />
    </div>
    <div style="margin-left: 10px; margin-right: 250px;">

        <h3>
            "A DREAM"
        </h3>
        <h4>
            Taras Shevchenko
        </h4>

        <hr />
        Each man on earth has his own fate, <br />
        Each one his highway wide: <br />
        This one builds up, that one lays waste, <br />
        And that casts greedy eyes <br />
        O’er all the globe, to find somewhere <br />
        A land not yet enslaved, <br />
        Which he could conquer and then bear <br />
        With him into the grave. <br />

        <hr />
        This fellow in his neighbour's home <br />
        His host cleans out at cards, <br />
        While that one in a corner hones <br />
        A blade for brother's heart. <br />
        Then there's the solid citizen, <br />
        The worthy, pious kind, <br />
        Who'll creep up like a cat and then <br />
        Bide patiently his time <br />
        Until hard luck hits your affairs, <br />
        Then pounce! — Don't plead your cause: <br />
        Your wife's appeals and children's tears <br />
        Won't save you from his claws. <br />
        And that one, generous and grand, <br />
        The fervent patriot, <br />
        So deeply loves his native land, <br />
        So worries o'er its lot, <br />
        As from his country's heart he sucks <br />
        The blood as though it was water!... <br />
        The brethren meanwhile sit and look, <br />
        Their eyes agape like saucers! <br />
        And bleat like lambs: "Perhaps it was <br />
        Thus ordained from on high." <br />
        That's how it's meant to be! Because <br />
        There's no God in the sky! <br />
        You pull your yoke until your breath <br />
        Gives out and you are done, <br />
        Yet pray for heaven after death? <br />
        In vain! There's none! There's none! <br />
        Your labour's lost. Come to! Come to! <br />
        In this world every one — <br />
        The princes, and the beggars, too, <br />
        They all are Adam's sons. <br />
        Both he... and he... What's this I prate? <br />
        What is it all about? <br />
        I banquet every single day, <br />
        Carouse day in, day out, <br />
        While you with envy burn and hate! <br />
        Don't scold: 'Twill do no good - <br />
        I'm deaf to you! I drink my own, <br />
        Not other people's blood! <br />

        <hr />

        Such thoughts went flitting through my head <br />
        As tipsy from a merry feast <br />
        In dead of night, on reeling feet, <br />
        I made my way to home and bed. <br />
        No bawling child or nagging spouse <br />
        Have I to spoil my rest — <br />
        With perfect peace I'm blest <br />
        Both in my mind and in my house. <br />
        I climbed into my bed <br />
        And soon slept like the dead. <br />
        And when a man has had a few, <br />
        Though cannon roar he still will snore, <br />
        He'll sleep whate'er you do. <br />
        <hr />

        Oh, what a vision rare I saw <br />
        In sleep that night: <br />
        A staunch abstainer would get iight, <br />
        A tightwad would a coin bestow, <br />
        If they could only get a glance. <br />
        But not a chance! <br />
        I dreamed: high in the air's expanse <br />
        It was as though an owl was flying <br />
        Over meadows, over valleys, <br />
        Over river banks and gulleys, <br />
        Over steppes and over forests. <br />
        And in the owl's wake I flew, too, <br />
        And flying, bid the earth adieu: <br />
        <hr />

        "Goodbye, O world, O earth, farewell, <br />
        Unfriendly land, goodbye! <br />
        My searing pain, my tortures cruel <br />
        Above the clouds I'll hide. <br />
        And as for you, my dear Ukraine, <br />
        I'll leave the clouds behind <br />
        And fall with dew to talk with you, <br />
        Poor widow-country mine. <br />
        I'll come at midnight when the dew <br />
        Falls heavy on the fields; <br />
        And softly-sadly we will talk <br />
        Of what the future yields. <br />
        Until the rising of the sun <br />
        We'll talk about your woes, <br />
        Until your infant sons are grown <br />
        And rise against the foes. <br />
        Goodbye, my lovely, poor Ukraine, <br />
        0 widow-land of mine! <br />
        Your children teach the living truth - <br />
        That justice is divine!" <br />
        <hr />

    </div>
</body>

<script>
    const is_paint_worklet_available = "paintWorklet" in CSS;
    const not_available_message = '`paintWorklet` is not avaliable in your browser';
    const words_to_search = ['what', 'man', 'thoughts', 'luck', 'come', 'is', 'heart', 'then', 'not', 'river', 'lot'];
    const words_to_avoid = ['lot'];
    const default_color = '#ffff00';

    async function wait(time) {
        return new Promise((resolve) => {
            setTimeout(resolve, time);
        });
    }

    /**
     * Represents a match object.
     * @typedef {Object} MatchObject
     * @property {Range} range - The range of the match.
     * @property {number} index - The index of the match.
     * @property {Node} node - The node of the match.
     * @property {HTMLElement} first_block_parent - The first block parent of the match.
     * @property {string} string - The string content of the match.
     * @property {number} start - The start index of the match.
     * @property {number} end - The end index of the match.
     */

    class Highlighter {
        detecting = false;
        /** @type {Set<Text>} */
        text_nodes = new Set();
        /** @type {Set<Text>} */
        text_nodes_new = new Set();
        /** @type {MatchObject[]} */
        matches = [];
        /** @type {Map<HTMLElement, MatchObject[]>} */
        matches_by_blocks = new Map();
        /** @type {string[]} */
        strings = [];
        saturation = 10;
        number_of_matches_all = 0;
        number_of_matches_visible = 0;
        /** @type {HTMLStyleElement} */
        style_main = document.createElement("style");
        /** @type {Map<HTMLElement, string>} */
        blocks_to_last_repaint_id = new Map();

        async init() {
            // init_styles
            this.set_highlight_color(default_color);
            document.head.append(this.style_main);

            // init_event_listeners
            window.addEventListener("mousedown", (e) => this.handle_user_interaction(), true);
            window.addEventListener("keydown", (e) => this.handle_user_interaction(), true);
            window.addEventListener("wheel", (e) => this.handle_user_interaction(), true);
            window.addEventListener("scroll", (e) => this.handle_user_interaction(), true);
            window.addEventListener("resize", (e) => this.handle_user_interaction(), true);
        }

        async handle_user_interaction() {
            if (this.detecting) {
                this.update_text_nodes();
                this.update_matches();
            }
        }

        /** @param {string} color */
        set_highlight_color(color) {
            this.style_main.innerHTML = `html { --highlight-color: ${color}; }`;
        }

        /**
         * @param {MouseEvent['clientX']} client_x - The x-coordinate of the client point.
         * @param {MouseEvent['clientY']} client_y - The y-coordinate of the client point.
         * @returns { ['word', DOMRect, string] | ['nothing'] } An array containing information about the data at the specified point.
         */
        get_data_from_point(client_x, client_y) {
            const elements = document.elementsFromPoint(client_x, client_y);
            for (const element of elements) {
                if (this.matches_by_blocks.has(element)) {
                    const matches = this.matches_by_blocks.get(element);
                    for (const match of matches) {
                        const rects = match.range.getClientRects();
                        for (const rect of rects) {
                            if (
                                rect.x < client_x &&
                                rect.y < client_y &&
                                rect.x + rect.width > client_x &&
                                rect.y + rect.height > client_y
                            ) {
                                return ["word", rect, match.string];
                            }
                        }
                    }
                }
            }
            return ["nothing"];
        }

        /**
         * @param {string[]} all_words 
         * @param {string[]} exclude_words 
         * @param {number} saturation 
         */
        restart_detecting(all_words, exclude_words, saturation = this.saturation) {
            this.detecting = true;
            this.reset();

            this.saturation = saturation;
            this.strings = all_words.reduce((acc, word) => (!exclude_words.includes(word)) ? [...acc, word] : acc, []);
            this.update_text_nodes();
            this.update_matches();
        }

        stop_detecting() {
            this.detecting = false;
            this.reset();
        }

        reset() {
            this.unpaint_blocks();
            this.text_nodes = new Set();
            this.text_nodes_new = new Set();
            this.matches = [];
            this.matches_by_blocks = new Map();
            this.number_of_matches_all = 0;
            this.number_of_matches_visible = 0;
        }

        update_text_nodes() {
            /** @type {Text|undefined} */
            let text_node;
            const walk = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null);
            while ((text_node = walk.nextNode())) {
                if (this.text_nodes.has(text_node) === false) {
                    this.text_nodes.add(text_node);
                    this.text_nodes_new.add(text_node);
                }
            }
        }

        /**
         * @param {string} str
         * @param {string[]} asl_words
         */
        get_words_with_indexes(str, asl_words) {
            const matchs = str.match(/[a-zA-Z0-9\$\&\_\+\-\:\^\.\']+|[^a-zA-Z0-9\$\&\_\+\-\:\^\.\']+/g);
            if (!matchs) return [];

            const words = [];
            let index = 0;
            for (let i = 0; i < matchs.length; i++) {
                if (matchs[i]) {
                    const option = matchs[i].toLowerCase()
                    if (asl_words.includes(option)) {
                        words.push({ index, text: option });
                    }
                    index += option.length;
                }
            }
            return words;
        }

        /** @param {Text} node */
        get_first_block_parent(node) {
            while (true) {
                const parentElement = node.parentElement;
                node = node.parentElement; // TODO: do not mutate node, try to save it in a new variable

                if (!parentElement) return false;

                const display = window.getComputedStyle(parentElement).display;
                if (display === "block") return parentElement;
            }
        }

        update_matches() {
            loop_1: for (let node of this.text_nodes_new) {
                this.text_nodes_new.delete(node);

                let text = node.nodeValue;
                if (!text) return;

                const words_with_indexes = this.get_words_with_indexes(text, this.strings);
                if (words_with_indexes.length < 0) return;

                const first_block_parent = this.get_first_block_parent(node);
                if (typeof first_block_parent === 'boolean') return;

                /** @type {MatchObject[]} */
                const matches = [];
                if (this.matches_by_blocks.has(first_block_parent) === false) {
                    this.matches_by_blocks.set(first_block_parent, []);
                    const resize_observer = new ResizeObserver(() => {
                        this.paint_block(first_block_parent);
                    });
                    resize_observer.observe(first_block_parent);
                }

                loop_2: for (const word of words_with_indexes) {
                    this.number_of_matches_all += 1;
                    if ((this.number_of_matches_visible / this.number_of_matches_all) <= this.saturation / 10) {
                        this.number_of_matches_visible += 1;
                    } else {
                        continue loop_2;
                    }

                    const range = document.createRange();
                    range.setStart(node, word.index);
                    range.setEnd(node, word.index + word.text.length);
                    matches.push({
                        range,
                        index: word.index,
                        node,
                        first_block_parent,
                        string: word.text,
                        start: word.index,
                        end: word.index + word.text.length,
                    });
                }
                if (first_block_parent) {
                    const set = this.matches_by_blocks.get(first_block_parent);
                    for (let match of matches) {
                        this.matches.push(match);
                        set.push(match);
                    }
                    this.paint_block(first_block_parent);
                }
            }
        }

        unpaint_blocks() {
            for (const block of this.matches_by_blocks.keys()) {
                const block_style = window.getComputedStyle(block);
                if (block_style.background === "rgba(0, 0, 0, 0) paint(signspaces-paint) repeat scroll 0% 0% / auto padding-box border-box") {
                    block.style.setProperty("--signspaces-items", "");
                    block.style.setProperty("background", "");
                }
            }
        }

        get_id() {
            return Date.now().toString(36) + Math.floor(Math.random() * 1_000_000_000_000).toString(36);
        }

        /** @param {HTMLElement} block */
        async paint_block(block) {
            const this_id = this.get_id();
            this.blocks_to_last_repaint_id.set(block, this_id);
            // await wait(500); // we can add delay before show highlightes

            const matches = this.matches_by_blocks.get(block);
            if (!matches) return;

            const last_id = this.blocks_to_last_repaint_id.get(block);
            if (this_id !== last_id) return;

            const block_style = window.getComputedStyle(block);
            if (
                block_style.background === "rgba(0, 0, 0, 0) none repeat scroll 0% 0% / auto padding-box border-box" ||
                block_style.background === "rgba(0, 0, 0, 0) paint(signspaces-paint) repeat scroll 0% 0% / auto padding-box border-box"
            ) {
            } else {
                return;
            }

            /** @type {[number, number, number, number][]} */
            const block_items = [];

            const block_rect = block.getBoundingClientRect();
            for (const match of matches) {
                try {
                    const match_rect_list = match.range.getClientRects();
                    for (const match_rect of match_rect_list) {
                        const item_x = match_rect.left - block_rect.left;
                        const item_y = match_rect.top - block_rect.top;
                        const item_width = match_rect.width;
                        const item_height = match_rect.height;
                        block_items.push([
                            item_x,
                            item_y,
                            item_width,
                            item_height
                        ]);
                    }
                } catch (e) {
                    console.log("error", e);
                }
            }
            block.style.setProperty("--signspaces-items", JSON.stringify(block_items));
            block.style.background = `paint(signspaces-paint)`;
        }
    }

    const highlighter = new Highlighter();
    const start = () => {
        if (!is_paint_worklet_available) {
            console.log(not_available_message);
            return
        }
        highlighter.restart_detecting(words_to_search, words_to_avoid);
    }
    const stop = () => {
        if (!is_paint_worklet_available) {
            console.log(not_available_message);
            return
        }
        highlighter.stop_detecting();
    }
    const color_change = (value) => {
        if (!is_paint_worklet_available) {
            console.log(not_available_message);
            return
        }
        const color_input = document.querySelector('input[type="color"]');
        if (!color_input) return;

        highlighter.set_highlight_color(color_input.value);
    }
    const saturation_change = (value) => {
        if (!is_paint_worklet_available) {
            console.log(not_available_message);
            return
        }
        const saturation_input = document.querySelector('input[type="range"]');
        if (!saturation_input) return;

        highlighter.restart_detecting(words_to_search, words_to_avoid, saturation_input.value);
    }
    (async () => {
        if (is_paint_worklet_available) {
            try {
                await highlighter.init();
                highlighter.restart_detecting(words_to_search, words_to_avoid);
                highlighter.set_highlight_color(default_color);

                await CSS.paintWorklet.addModule("checkboardWorklet.js")
                console.log('paintWorklet:OK');
                document.addEventListener(
                    "mousemove",
                    async ({ clientX, clientY }) => {
                        const [data_type, rect, string] = highlighter.get_data_from_point(clientX, clientY);
                        switch (data_type) {
                            case 'word': {
                                console.log('word', {
                                    word: string,
                                    positon: rect
                                });
                                break;
                            }
                            case 'nothing': {
                                console.log('nothing');
                                break;
                            }
                            default:
                                break;
                        }
                    },
                    true
                );
            } catch (error) {
                console.log('paintWorklet:ERROR');
            }
        } else {
            console.log(not_available_message);
        }
    })();
</script>

</html>