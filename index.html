<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        /* li {
            background-image: paint(checkerboard);
        } */
    </style>
    <style>
        :root {
        }
        
        #example {
            --fillC: #ff0000;
            width: 200px;
            height: 200px;
            background-image: paint(arc);
            /* background-image: paint(arc, var(--fillC)); */
            /* background-image: paint(arc, green); */
        }
    </style>
</head>

<body>
    <div>
        <div>
            Hello
        </div>

        <li>
            Hello
        </li>
        Hello
    </div>
    <p>
        Hello
    </p>
    <div>
        Lorem hi ipsum Hello dolor sit, amet consectetur adipisicing elit. Quibusdam, aliquid eligendi eveniet dolore
        accusamus
        voluptatibus, vitae cumque perspiciatis minima quas totam aut corrupti corporis praesentium possimus dicta ipsa!
        Adipisci, vero!
    </div>
    <hr />
    <div id="example">
        wewegweg
    </div>
</body>

<script>
    async function wait(time) {
        return new Promise((resolve) => {
            setTimeout(resolve, time);
        });
    }
    class Highlighter {
        detecting = false;
        text_nodes = new Set();
        text_nodes_new = new Set();
        matches = [];
        matches_by_blocks = new Map();
        rects_by_blocks = new Map();
        blocks_with_resize_observer = new Set();
        strings = [];
        saturation = 10;
        number_of_matches_all = 0;
        number_of_matches_visible = 0;
        signspaces_style_main;
        constructor() {
            this.signspaces_style_main = document.createElement("style");
        }
        async init() {
            this.init_styles();
            this.init_eventListeners();
        }
        init_styles() {
            this.signspaces_style_main.classList.add("signspaces-style-main");
            this.set_highlight_color({ color: "red" });

            document.head.append(this.signspaces_style_main);
        }
        init_eventListeners() {
            window.addEventListener("mousedown", (e) => this.handle_user_interaction(), true);
            window.addEventListener("keydown", (e) => this.handle_user_interaction(), true);
            window.addEventListener("wheel", (e) => this.handle_user_interaction(), true);
            window.addEventListener("scroll", (e) => this.handle_user_interaction(), true);
            window.addEventListener("resize", (e) => this.handle_user_interaction(), true);
        }
        set_highlight_color({ color }) {
            this.signspaces_style_main.innerHTML = `html { --signspaces-highlight-color: ${color}; }`;
        }
        get_data_from_point(
            client_x,
            client_y,
            options = {}
        ) {
            let elements = document.elementsFromPoint(client_x, client_y);
            loop_1: for (let element of elements) {
                if (this.matches_by_blocks.has(element)) {
                    let matches = this.matches_by_blocks.get(element);
                    for (let match of matches) {
                        let rects = match.range.getClientRects();
                        for (let rect of rects) {
                            //
                            if (
                                //
                                rect.x < client_x &&
                                rect.y < client_y &&
                                rect.x + rect.width > client_x &&
                                rect.y + rect.height > client_y
                            ) {
                                return ["word", rect, match.string];
                            }
                            //
                        }
                    }
                } else if (element.classList.contains("chromane-signspaces-card")) {
                    return ["signspaces-card"];
                }
            }
            return ["nothing"];
        }
        restart_detecting(all_words, removed_words, saturation) {
            //
            this.detecting = true;
            //
            let strings = [];
            // console.log('strings', strings);
            for (let word of all_words) {
                if (removed_words.includes(word)) {
                    // skip
                } else {
                    strings.push(word);
                }
            }
            //
            this.unpaint_blocks();
            //
            this.text_nodes = new Set();
            this.text_nodes_new = new Set();
            this.matches = [];
            this.matches_by_blocks = new Map();
            this.rects_by_blocks = new Map();
            this.blocks_with_resize_observer = new Set();
            //
            this.strings = strings;
            this.saturation = saturation;
            //
            this.number_of_matches_all = 0;
            this.number_of_matches_visible = 0;
            //
            this.update_text_nodes();
            this.update_matches();
            //
        }
        // stop_detecting() {
        //     this.detecting = false;
        //     //
        //     this.unpaint_blocks();
        //     //
        //     this.text_nodes = new Set();
        //     this.text_nodes_new = new Set();
        //     this.matches = [];
        //     this.matches_by_blocks = new Map();
        //     this.rects_by_blocks = new Map();
        //     this.blocks_with_resize_observer = new Set();
        //     //
        //     this.number_of_matches_all = 0;
        //     this.number_of_matches_visible = 0;
        //     //
        //     // this.update_text_nodes();
        //     // this.update_matches();
        //     //
        // }
        update_text_nodes() {
            let text_node;
            var walk = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null);
            while ((text_node = walk.nextNode())) {
                if (this.text_nodes.has(text_node) === false) {
                    // console.log('text_node', text_node);
                    this.text_nodes.add(text_node);
                    this.text_nodes_new.add(text_node);
                    // console.log('this.text_nodes_new', this.text_nodes_new);
                }
            }
        }
        get_first_block_parent(node) {
            while (true) {
                node = node.parentElement;
                if (node) {
                    let display = window.getComputedStyle(node).display;
                    if (display === "block") {
                        return node;
                    }
                } else {
                    return false;
                }
            }
        }
        get_words_with_indexes(str, asl_words) {
            var words = [];
            // var match = str.match( /[0-9a-zA-Z\+\^]+|[^0-9a-zA-Z\+\^]+/g );
            // match word characters and non-word characters, so that the entire string is divided into
            // parts that put together the entire string
            var match = str.match(/[a-zA-Z0-9\$\&\_\+\-\:\^\.\']+|[^a-zA-Z0-9\$\&\_\+\-\:\^\.\']+/g);
            // console.log('match', match);
            var index = 0;
            if (match) {
                for (var i = 0; i < match.length; i) {
                    let lowercase_match = match[i].match(/^[a-zA-Z\$\_\+\-\:\^\.]+$/);
                    let number_of_processed_items = 0;
                    if (lowercase_match) {
                        // create multiple options for phrases
                        // with multiple words
                        let option_3;
                        let option_2;
                        let option_1;
                        if (match[i + 4]) {
                            option_3 = match[i] + "-" + match[i + 2] + "-" + match[i + 4];
                            option_3 = option_3.toLowerCase();
                        }
                        if (match[i + 2]) {
                            option_2 = match[i] + "-" + match[i + 2];
                            option_2 = option_2.toLowerCase();
                        }
                        if (match[i]) {
                            option_1 = match[i];
                            option_1 = option_1.toLowerCase();
                        }
                        //
                        let ticker_was_found = false;
                        let ticker_text = "";
                        if (option_3 && asl_words.indexOf(option_3) > -1) {
                            option_3 = option_3.replace(/\.$/, "").toLowerCase();
                            ticker_was_found = true;
                            ticker_text = option_3;
                            number_of_processed_items = 5;
                        } else if (option_2 && asl_words.indexOf(option_2) > -1) {
                            option_2 = option_2.replace(/\.$/, "").toLowerCase();
                            ticker_was_found = true;
                            ticker_text = option_2;
                            number_of_processed_items = 3;
                        } else if (option_1 && asl_words.indexOf(option_1) > -1) {
                            option_1 = option_1.replace(/\.$/, "").toLowerCase();
                            ticker_was_found = true;
                            ticker_text = option_1;
                            number_of_processed_items = 1;
                        } else {
                            number_of_processed_items = 1;
                        }
                        if (ticker_was_found) {
                            words.push({
                                index,
                                text: ticker_text,
                            });
                        }
                    } else {
                        number_of_processed_items = 1;
                    }
                    for (let j = 0; j < number_of_processed_items; j++) {
                        if (match[i]) {
                            index += match[i].length;
                        }
                        i++;
                    }
                }
            }
            // console.log('words', words);
            return words;
        }
        update_matches() {
            loop_1: for (let node of this.text_nodes_new) {
                this.text_nodes_new.delete(node);
                // let strings = [] as any;
                // for (let key_lang in sign.words) {
                //   for (let lang_variant of sign.words[key_lang]) {
                //     strings.push(lang_variant);
                //   }
                // }
                let text = node.nodeValue;
                // console.log('text', text);
                //
                if (text) {
                    // console.log('this.strings', this.strings);
                    let matches = [];
                    let words_with_indexes = this.get_words_with_indexes(text, this.strings);
                    if (words_with_indexes && words_with_indexes.length > 0) {
                        // console.log('words_with_indexes', words_with_indexes);
                        let first_block_parent = this.get_first_block_parent(node);
                        // console.log('first_block_parent',
                        //     this.matches_by_blocks.has(first_block_parent) === false,
                        //     this.matches_by_blocks,
                        //     first_block_parent
                        // );
                        if (this.matches_by_blocks.has(first_block_parent) === false) {
                            this.matches_by_blocks.set(first_block_parent, []);
                            let resize_observer = new ResizeObserver(() => {
                                // console.log("resize");
                                this.paint_block(first_block_parent);
                            });
                            resize_observer.observe(first_block_parent);
                        }
                        // let resize_observer = new ResizeObserver(() => {
                        //   this.paint_block(first_block_parent);
                        // });
                        // if (node.parentElement) {
                        //   resize_observer.observe(node.parentElement);
                        // }
                        loop_2: for (let word of words_with_indexes) {
                            //
                            this.number_of_matches_all += 1;
                            if (this.number_of_matches_visible / this.number_of_matches_all <= this.saturation / 10) {
                                // show
                                // continue
                                this.number_of_matches_visible += 1;
                            } else {
                                // skip
                                continue loop_2;
                            }
                            //
                            var range = document.createRange();
                            range.setStart(node, word.index);
                            range.setEnd(node, word.index + word.text.length);
                            //
                            let match = {
                                range,
                                index: word.index,
                                node,
                                first_block_parent,
                                string: word.text,
                                start: word.index,
                                end: word.index + word.text.length,
                            };
                            //
                            matches.push(match);
                            //
                        }
                        if (first_block_parent) {
                            //
                            let set = this.matches_by_blocks.get(first_block_parent);
                            for (let match of matches) {
                                this.matches.push(match);
                                set.push(match);
                            }
                            this.paint_block(first_block_parent);
                        }
                    }
                    //
                }
            }
        }
        async handle_user_interaction() {
            if (this.detecting) {
                // let should_run_now = await interval("handle_user_interaction", 1000);
                this.update_text_nodes();
                this.update_matches();
                // if (should_run_now) {
                // }
            }
        }
        unpaint_blocks() {
            for (let block of this.matches_by_blocks.keys()) {
                let block_style = window.getComputedStyle(block);
                if (block_style.background === "rgba(0, 0, 0, 0) paint(signspaces-paint) repeat scroll 0% 0% / auto padding-box border-box") {
                    block.style.setProperty("--signspaces-items", "");
                    block.style.setProperty("background", "");
                }
            }
        }
        get_id() {
            return Date.now().toString(36) + Math.floor(Math.random() * 1_000_000_000_000).toString(36);
        }
        blocks_to_last_repaint_id = new Map();
        async paint_block(block) {
            let matches = this.matches_by_blocks.get(block);
            // console.log('--------------', block, matches);
            //
            let this_id = this.get_id();
            this.blocks_to_last_repaint_id.set(block, this_id);
            //
            await wait(50);
            let last_id = this.blocks_to_last_repaint_id.get(block);

            if (this_id !== last_id) {
                // console.log("skipped");
            }

            //
            //
            //
            if (this_id === last_id && matches) {
                let rect_1 = block.getBoundingClientRect();
                let block_items = [];
                let rects = [];
                //
                let block_style = window.getComputedStyle(block);
                // console.log('block_style', block_style.background);
                // todo: improve performance, we only need to get computed style once
                if (
                    //
                    block_style.background === "rgba(0, 0, 0, 0) none repeat scroll 0% 0% / auto padding-box border-box" ||
                    block_style.background === "rgba(0, 0, 0, 0) paint(signspaces-paint) repeat scroll 0% 0% / auto padding-box border-box"
                ) {
                    // continue
                } else {
                    return;
                }
                //
                // console.log('matches', matches);
                for (let match of matches) {
                    try {
                        //
                        let rect_2_arr = match.range.getClientRects();
                        // match.node.parentElement.style.backgroundImage = `url(${image_url})`;
                        // match.node.parentElement.style.background = `paint(signspaces, 0.4)`;
                        //
                        for (let rect_2 of rect_2_arr) {
                            let item_x = rect_2.left - rect_1.left;
                            let item_y = rect_2.top - rect_1.top;
                            let item_width = rect_2.width;
                            let item_height = rect_2.height;
                            //
                            block_items.push([item_x, item_y, item_width, item_height]);
                            rects.push([rect_2.left, rect_2.y, rect_2.width, rect_2.height, match.string]);
                            //
                        }
                        //
                    } catch (e) {
                        console.log("error", e);
                    }
                }
                // console.log('block_items', block_items);
                this.rects_by_blocks.set(block, rects);
                block.style.setProperty("--signspaces-items", JSON.stringify(block_items));
                // console.log("--signspaces-items", JSON.stringify(block_items));
                block.style.background = `paint(signspaces-paint)`;
                // block.style.setProperty("--patternType", "green");
            }
        }
    }

    (async () => {
        const highlighter = new Highlighter();
        await highlighter.init();
        highlighter.set_highlight_color({ color: 'yellow' })
        highlighter.restart_detecting(['hello', 'possimus', 'dolore', 'hi', 'sit'], ['hi'], 10);

        if ("paintWorklet" in CSS) {
            CSS.paintWorklet.addModule("checkboardWorklet.js").then(() => {
                console.log('OK');
            })
            .catch(() => {
                console.log('ERROR');
            });
        }
    })();
    // CSS.paintWorklet.addModule('arc.js');
</script>

</html>